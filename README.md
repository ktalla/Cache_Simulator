## Cache Simulator

### Memory Access Traces
The format and structure of the memory traces are described below. The input to the
cache simulator is a memory access trace, which has been generated by executing real programs.
The trace contains memory addresses accessed during program execution. The cache simulator
uses these addresses to determine if the access is a hit or a miss, and the actions to
perform in each case. 

The memory trace file consists of multiple lines. Each line of the trace file
corresponds to a memory accesses performed by the program. Each line consists of two columns,
which are space separated. First column lists whether the memory access is a read (R) or a write
(W) operation. The second column reports the actual 48-bit memory address that has been accessed
by the program.

Here is a sample trace file.<br>
R 0x9cb3d40<br>
W 0x9cb3d40<br>
R 0x9cb3d44<br>
W 0x9cb3d44<br>
R 0xbf8ef498<br>


### Cache Replacement Policies
The goal of the cache replacement policy is to decide which block has to be evicted in case there is no space in the set for an incoming cache block. It is always preferable – to achieve the best performance– to replace the block that will be re-referenced furthest in the future. In this project, there are two different cache replacement policies: FIFO and LRU.

### FIFO
When the cache uses the FIFO replacement policy, it always evicts the block accessed first in the set without considering how often or how many times the block was accessed before. So let us say that your cache is empty initially and that each set has two ways. Now suppose that you access blocks A, B, A, C. To make room for C, you would evict A since it was the first block to be brought into the set.
### LRU
When the cache uses the LRU replacement policy, it discards the least recently used items first. The cache with an LRU policy has to keep track of all accesses to a block and always evict the block that has been used (or accessed) least recently as the name suggests.

### Cache Simulator Interface
You have to name your cache simulator first. Your program should support the following usageinterface:<br>
./first <cachesize><assoc:n><cache policy><block size><trace file>
where:<br>
• The parameter cache size is the total size of the cache in bytes. This number should be a
power of 2.
• The parameter assoc:n specifies the associativity. Here, n is a number of cache lines in a set.
• The parameter cache policy specifies the cache replacement policy, which is either fifo or lru.
• The parameter block size is a power of 2 that specifies the size of the cache block in bytes.
• The parameter trace file is the name of the trace file.

### Simulation Details
• (a) When the program starts, there is nothing in the cache. So, all cache lines are empty. (b) you can assume that the memory size is 248. Therefore, memory addresses are at most 48-bit (zero extend the addresses in the trace file if they are less than 48-bit in length). (c) the number of bits in the tag, cache address, and byte address are determined by the cache size and the block size.
• For a write-through cache, there is an assumption that the block is first read from memory (i.e., one memory read), and then followed by a memory write.
• Data is not simulated because the trace does not contain any information on data values transferred between memory and caches.

### Input-Output:
The program should print out the number of memory reads (per cache block), memory writes (per cache block), cache hits, and cache misses.
$./first 32 assoc:2 fifo 4 trace1.txt<br>
memread:336<br>
memwrite:334<br>
cachehit:664<br>
cachemiss:336<br>
The above example, simulates a 2-way set associate cache of size 32 bytes. Each cache block is 4 bytes. The trace file name is trace1.txt.
